Q1：哪些寄存器用来存放函数所用的参数？比如在main函数中调用printf时13这个参数是在哪个寄存器中传递进去的？
A1：我们看看printf这段代码对应的汇编及其注释，如下所示：
printf("%d %d\n", f(8)+1, 13);
 24:	4635              li	a2,13		# 将13放置到a2寄存器
 26:	45b1              li	a1,12		# 将12放置到a1寄存器
 28:	00000517          auipc	a0,0x0		# a0 = pc = 0x28
 2c:	7a050513          addi	a0,a0,1952 	# a0 = a0 + 1952 = 0x28 + 0x7a0 = 0x7c8
 30:	00000097          auipc	ra,0x0		# ra = pc = 0x30
 34:	5f8080e7          jalr	1528(ra) 	# pc = ra + 1528 = 0x30 + 0x5f8 = 0x628
我们可以看到13被放置到了a2寄存器中，而表示计算结果的f(8) + 1 = 8 + 3 + 1 = 12则被放置到了a1寄存器中，a0指向了一个地址7c8，可以想见这个地址应该是指向printf函数中第一个输出格式字符串的地址。上述的参数传递是符合RISC-V的calling convention的，事实上在传递整数参数时，如果参数个数少于8个，它们都会被放置在a0-a7中进行传递。

Q2：main函数中对f函数调用的汇编代码在哪里？对g函数的调用又在哪里？(提示：编译器可以对函数进行内联)
A2：从上述的汇编代码中可以看到，编译器直接将对f函数的调用结果硬编码到了代码中，这样可以极大程度地减少函数调用过程的开销。

Q3：printf函数的地址是什么？
A3：从上述代码中可以看出，printf函数的地址就是最后一行汇编执行完成之后的PC的值，为0x628。

Q4：在main函数中执行完跳转到printf函数的jalr指令之后，ra寄存器的值是什么？
A4：上面我们已经计算出来了，ra寄存器的值应该是0x38，我们可以借这个机会熟悉一下GDB的用法，调试一下call.c这个用户程序，看看我们计算结果是否正确，调试的步骤如下，这也是在Xv6中调试用户态程序的基本方法，建议熟练掌握：

Q5<： 执行下面的代码会输出什么？
unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
输出基于这样一个事实，RISC-V是一个基于小端的(little-endian)，如果RISC-V是基于大端的那么应该如何修改i的值来产生同样的输出？你需要将57616修改为不同的值吗？
A5：首先将这段代码写入call.c，编译运行一下，结果：
输出了一个"He110 World"，其中e110是57616的16进制表示，而rld是无符号整数i中每个字节的对应字符。如果现在RISC-V存储改为大端，i的值就应该初始化为0x00726c46了，而57616无需修改，因为大小端存放并不会改变它转化为16进制数之后的结果。

Q6：在下面的代码中，y= 之后会打印出什么？(此值不确定)，这是为什么？
A6：我们将call.c文件中的main函数替换为上述代码，编译执行

首先上述行为是没有定义的行为(Undefined Behavior)，因为printf中传入的参数数量少于格式化字符串中要求的数量，我不打算在此详细介绍前因后果(涉及到va_list等等，而va_list其实是一个指针，指向一块连续的内存区域)，写出来篇幅会很长。我使用GDB调试了上述程序，发现5309其实是紧跟在3之后的一块未初始化的内存数据，这就是问题的答案。
